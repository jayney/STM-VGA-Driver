/*
* Copyright 2022 Jayne Atkinson
*
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software
* and associated documentation files (the "Software"), to deal in the Software without restriction,
* including without limitation the rights to use, copy, modify, merge, publish, distribute,
* sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
* is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all copies
* or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
* AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
*
*/


/* This provides basic monochrome video output from a STM32F4 Microcontroller  

   It was developed and tested on a Nucleo 446RE development board.
   It will probably port to other F4 devices, subject to available resources,
   with little or no modification. YMMV with other families, especially 
   "General Purpose" families such as F0/F3/L4 etc due to h/w differences

   Resources Used:
     ~7k Flash
     ~62k RAM
     Timer 2 - VSYNC          default PA5
     Timer 3 - HSYNC          default PA6
     SPI 1 MOSI - Video Out   default PB5
     DMA Controller 2 Stream 5, Channel 3

     Compiles under PlatformIO, using the LibOpenCM3 framework.

  Other 16 bit General Purpose timers should also work, and other SPI modules
  should work too. But this will need to be hard coded in the appropriate 
  setup functions. I am not a very good coder, certainly not good enough to 
  allocate resources on the fly, a la Arduino.

  The currently coded mode is 800x600, 1bpp, 37.878kHz Horizontal, 60Hz Vertical, 40MHz Pixel Clock.
  Changing main clock, timer settings and some #defines will allow other resolutions. YMMV.

  I've tested with a LG TV, with 33 Ohm resistors in series with the two Sync connections, and a 470 Ohm in series
  with the output and one or more colour inputs. Ensure you KNOW what you are doing before connecting to a monitor.

  I accept NO responsibility for any damage incurred to monitors/microcontrollers (especially CRTs!), nor for personal injury.

  Version History:
  v0.1  29/03/2022  Initial Release

*/






#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/timer.h>
#include <libopencm3/cm3/nvic.h>
#include <libopencm3/stm32/dac.h>
#include <libopencm3/stm32/dma.h>
#include <libopencm3/stm32/spi.h>
#include <libopencm3/stm32/flash.h> 

#include "vga.h"

volatile uint8_t video_buffer[LINES][LINE_SIZE+1];
uint8_t blank_line[LINE_SIZE+3];
uint16_t current_line = 0;
uint16_t scan_line = 0;

volatile uint8_t cursor_x = 0;
volatile uint8_t cursor_y = 0;


// Character Generator Data
const volatile uint8_t __attribute__ ((aligned (256))) charset[8][256] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x18,0x66,0x66,0x18,0x62,0x3C,0x06,0x0C,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x18,0x3C,0x3C,0x06,0x7E,0x3C,0x7E,0x3C,0x3C,0x00,0x00,0x0E,0x00,0x70,0x3C,0x3C,0x18,0x7C,0x3C,0x78,0x7E,0x7E,0x3C,0x66,0x3C,0x1E,0x66,0x60,0x63,0x66,0x3C,0x7C,0x3C,0x7C,0x3C,0x7E,0x66,0x66,0x63,0x66,0x66,0x7E,0x3C,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x18,0x70,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0xFF,0xFF,0x01,0x80,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0x99,0x99,0xE7,0x9D,0xC3,0xF9,0xF3,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC3,0xE7,0xC3,0xC3,0xF9,0x81,0xC3,0x81,0xC3,0xC3,0xFF,0xFF,0xF1,0xFF,0x8F,0xC3,0xC3,0xE7,0x83,0xC3,0x87,0x81,0x81,0xC3,0x99,0xC3,0xE1,0x99,0x9F,0x9C,0x99,0xC3,0x83,0xC3,0x83,0xC3,0x81,0x99,0x99,0x9C,0x99,0x99,0x81,0xC3,0xFF,0xC3,0xFF,0xFF,0xC3,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF1,0xE7,0x8F,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,0x18,0x66,0x66,0x3E,0x66,0x66,0x0C,0x18,0x18,0x66,0x18,0x00,0x00,0x00,0x03,0x66,0x18,0x66,0x66,0x0E,0x60,0x66,0x66,0x66,0x66,0x00,0x00,0x18,0x00,0x18,0x66,0x66,0x3C,0x66,0x66,0x6C,0x60,0x60,0x66,0x66,0x18,0x0C,0x6C,0x60,0x77,0x76,0x66,0x66,0x66,0x66,0x66,0x18,0x66,0x66,0x63,0x66,0x66,0x06,0x30,0x60,0x0C,0x18,0x00,0x66,0x00,0x60,0x00,0x06,0x00,0x0E,0x00,0x60,0x18,0x06,0x60,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x00,0x10,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x7F,0xFE,0x03,0xC0,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0x99,0x99,0xC1,0x99,0x99,0xF3,0xE7,0xE7,0x99,0xE7,0xFF,0xFF,0xFF,0xFC,0x99,0xE7,0x99,0x99,0xF1,0x9F,0x99,0x99,0x99,0x99,0xFF,0xFF,0xE7,0xFF,0xE7,0x99,0x99,0xC3,0x99,0x99,0x93,0x9F,0x9F,0x99,0x99,0xE7,0xF3,0x93,0x9F,0x88,0x89,0x99,0x99,0x99,0x99,0x99,0xE7,0x99,0x99,0x9C,0x99,0x99,0xF9,0xCF,0x9F,0xF3,0xE7,0xFF,0x99,0xFF,0x9F,0xFF,0xF9,0xFF,0xF1,0xFF,0x9F,0xE7,0xF9,0x9F,0xC7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xE7,0xE7,0xFF,0xEF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x70,0x00,0x18,0x66,0xFF,0x60,0x0C,0x3C,0x18,0x30,0x0C,0x3C,0x18,0x00,0x00,0x00,0x06,0x6E,0x38,0x06,0x06,0x1E,0x7C,0x60,0x0C,0x66,0x66,0x18,0x18,0x30,0x7E,0x0C,0x06,0x6E,0x66,0x66,0x60,0x66,0x60,0x60,0x60,0x66,0x18,0x0C,0x78,0x60,0x7F,0x7E,0x66,0x66,0x66,0x66,0x60,0x18,0x66,0x66,0x63,0x3C,0x66,0x0C,0x30,0x30,0x0C,0x3C,0x00,0x6E,0x3C,0x60,0x3C,0x06,0x3C,0x18,0x3E,0x60,0x00,0x00,0x60,0x18,0x66,0x7C,0x3C,0x7C,0x3E,0x7C,0x3E,0x7E,0x66,0x66,0x63,0x66,0x66,0x7E,0x18,0x18,0x18,0x00,0x30,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x1C,0x38,0x3F,0xFC,0x07,0xE0,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0x99,0x00,0x9F,0xF3,0xC3,0xE7,0xCF,0xF3,0xC3,0xE7,0xFF,0xFF,0xFF,0xF9,0x91,0xC7,0xF9,0xF9,0xE1,0x83,0x9F,0xF3,0x99,0x99,0xE7,0xE7,0xCF,0x81,0xF3,0xF9,0x91,0x99,0x99,0x9F,0x99,0x9F,0x9F,0x9F,0x99,0xE7,0xF3,0x87,0x9F,0x80,0x81,0x99,0x99,0x99,0x99,0x9F,0xE7,0x99,0x99,0x9C,0xC3,0x99,0xF3,0xCF,0xCF,0xF3,0xC3,0xFF,0x91,0xC3,0x9F,0xC3,0xF9,0xC3,0xE7,0xC1,0x9F,0xFF,0xFF,0x9F,0xE7,0x99,0x83,0xC3,0x83,0xC1,0x83,0xC1,0x81,0x99,0x99,0x9C,0x99,0x99,0x81,0xE7,0xE7,0xE7,0xFF,0xCF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x38,0x00,0x18,0x00,0x66,0x3C,0x18,0x38,0x00,0x30,0x0C,0xFF,0x7E,0x00,0x7E,0x00,0x0C,0x76,0x18,0x0C,0x1C,0x66,0x06,0x7C,0x18,0x3C,0x3E,0x00,0x00,0x60,0x00,0x06,0x0C,0x6E,0x7E,0x7C,0x60,0x66,0x78,0x78,0x6E,0x7E,0x18,0x0C,0x70,0x60,0x6B,0x7E,0x66,0x7C,0x66,0x7C,0x3C,0x18,0x66,0x66,0x6B,0x18,0x3C,0x18,0x30,0x18,0x0C,0x7E,0x00,0x6E,0x06,0x7C,0x60,0x3E,0x66,0x3E,0x66,0x7C,0x38,0x06,0x6C,0x18,0x7F,0x66,0x66,0x66,0x66,0x66,0x60,0x18,0x66,0x66,0x6B,0x3C,0x66,0x0C,0x70,0x18,0x0E,0x3B,0x7F,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0xFF,0x07,0xE0,0x0F,0xF0,0x1F,0xF8,0x0F,0xF0,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0xFF,0x99,0xC3,0xE7,0xC7,0xFF,0xCF,0xF3,0x00,0x81,0xFF,0x81,0xFF,0xF3,0x89,0xE7,0xF3,0xE3,0x99,0xF9,0x83,0xE7,0xC3,0xC1,0xFF,0xFF,0x9F,0xFF,0xF9,0xF3,0x91,0x81,0x83,0x9F,0x99,0x87,0x87,0x91,0x81,0xE7,0xF3,0x8F,0x9F,0x94,0x81,0x99,0x83,0x99,0x83,0xC3,0xE7,0x99,0x99,0x94,0xE7,0xC3,0xE7,0xCF,0xE7,0xF3,0x81,0xFF,0x91,0xF9,0x83,0x9F,0xC1,0x99,0xC1,0x99,0x83,0xC7,0xF9,0x93,0xE7,0x80,0x99,0x99,0x99,0x99,0x99,0x9F,0xE7,0x99,0x99,0x94,0xC3,0x99,0xF3,0x8F,0xE7,0xF1,0xC4,0x80,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x1C,0x00,0x00,0x00,0xFF,0x06,0x30,0x67,0x00,0x30,0x0C,0x3C,0x18,0x00,0x00,0x00,0x18,0x66,0x18,0x30,0x06,0x7F,0x06,0x66,0x18,0x66,0x06,0x00,0x00,0x30,0x7E,0x0C,0x18,0x60,0x66,0x66,0x60,0x66,0x60,0x60,0x66,0x66,0x18,0x0C,0x78,0x60,0x63,0x6E,0x66,0x60,0x66,0x78,0x06,0x18,0x66,0x66,0x7F,0x3C,0x18,0x30,0x30,0x0C,0x0C,0x18,0x00,0x60,0x3E,0x66,0x60,0x66,0x7E,0x18,0x66,0x66,0x18,0x06,0x78,0x18,0x7F,0x66,0x66,0x66,0x66,0x60,0x3C,0x18,0x66,0x66,0x7F,0x18,0x66,0x18,0x18,0x18,0x18,0x6E,0x7F,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0xFF,0x0F,0xF0,0x07,0xE0,0x0F,0xF0,0x1F,0xF8,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xF9,0xCF,0x98,0xFF,0xCF,0xF3,0xC3,0xE7,0xFF,0xFF,0xFF,0xE7,0x99,0xE7,0xCF,0xF9,0x80,0xF9,0x99,0xE7,0x99,0xF9,0xFF,0xFF,0xCF,0x81,0xF3,0xE7,0x9F,0x99,0x99,0x9F,0x99,0x9F,0x9F,0x99,0x99,0xE7,0xF3,0x87,0x9F,0x9C,0x91,0x99,0x9F,0x99,0x87,0xF9,0xE7,0x99,0x99,0x80,0xC3,0xE7,0xCF,0xCF,0xF3,0xF3,0xE7,0xFF,0x9F,0xC1,0x99,0x9F,0x99,0x81,0xE7,0x99,0x99,0xE7,0xF9,0x87,0xE7,0x80,0x99,0x99,0x99,0x99,0x9F,0xC3,0xE7,0x99,0x99,0x80,0xE7,0x99,0xE7,0xE7,0xE7,0xE7,0x91,0x80,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x0E,0x00,0x00,0x00,0x66,0x7C,0x66,0x66,0x00,0x18,0x18,0x66,0x18,0x18,0x00,0x18,0x30,0x66,0x18,0x60,0x66,0x06,0x66,0x66,0x18,0x66,0x66,0x18,0x18,0x18,0x00,0x18,0x00,0x66,0x66,0x66,0x66,0x6C,0x60,0x60,0x66,0x66,0x18,0x6C,0x6C,0x60,0x63,0x66,0x66,0x60,0x3C,0x6C,0x66,0x18,0x66,0x3C,0x77,0x66,0x18,0x60,0x30,0x06,0x0C,0x18,0x00,0x66,0x66,0x66,0x60,0x66,0x60,0x18,0x3E,0x66,0x18,0x06,0x6C,0x18,0x6B,0x66,0x66,0x7C,0x3E,0x60,0x06,0x18,0x66,0x3C,0x3E,0x3C,0x3E,0x30,0x18,0x18,0x18,0x00,0x30,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x1C,0x38,0x00,0x00,0x07,0xE0,0x3F,0xFC,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x99,0x83,0x99,0x99,0xFF,0xE7,0xE7,0x99,0xE7,0xE7,0xFF,0xE7,0xCF,0x99,0xE7,0x9F,0x99,0xF9,0x99,0x99,0xE7,0x99,0x99,0xE7,0xE7,0xE7,0xFF,0xE7,0xFF,0x99,0x99,0x99,0x99,0x93,0x9F,0x9F,0x99,0x99,0xE7,0x93,0x93,0x9F,0x9C,0x99,0x99,0x9F,0xC3,0x93,0x99,0xE7,0x99,0xC3,0x88,0x99,0xE7,0x9F,0xCF,0xF9,0xF3,0xE7,0xFF,0x99,0x99,0x99,0x9F,0x99,0x9F,0xE7,0xC1,0x99,0xE7,0xF9,0x93,0xE7,0x94,0x99,0x99,0x83,0xC1,0x9F,0xF9,0xE7,0x99,0xC3,0xC1,0xC3,0xC1,0xCF,0xE7,0xE7,0xE7,0xFF,0xCF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x18,0x00,0x66,0x18,0x46,0x3F,0x00,0x0C,0x30,0x00,0x00,0x18,0x00,0x18,0x60,0x3C,0x7E,0x7E,0x3C,0x06,0x3C,0x3C,0x18,0x3C,0x3C,0x00,0x18,0x0E,0x00,0x70,0x18,0x3C,0x66,0x7C,0x3C,0x78,0x7E,0x60,0x3C,0x66,0x3C,0x38,0x66,0x7E,0x63,0x66,0x3C,0x60,0x0E,0x66,0x3C,0x18,0x3C,0x18,0x63,0x66,0x18,0x7E,0x3C,0x03,0x3C,0x18,0xFF,0x3C,0x3E,0x7C,0x3C,0x3E,0x3C,0x18,0x06,0x66,0x3C,0x06,0x66,0x3C,0x63,0x66,0x3C,0x60,0x06,0x60,0x7C,0x0E,0x3E,0x18,0x36,0x66,0x0C,0x7E,0x0E,0x18,0x70,0x00,0x10,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x03,0xC0,0x7F,0xFE,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xE7,0xFF,0x99,0xE7,0xB9,0xC0,0xFF,0xF3,0xCF,0xFF,0xFF,0xE7,0xFF,0xE7,0x9F,0xC3,0x81,0x81,0xC3,0xF9,0xC3,0xC3,0xE7,0xC3,0xC3,0xFF,0xE7,0xF1,0xFF,0x8F,0xE7,0xC3,0x99,0x83,0xC3,0x87,0x81,0x9F,0xC3,0x99,0xC3,0xC7,0x99,0x81,0x9C,0x99,0xC3,0x9F,0xF1,0x99,0xC3,0xE7,0xC3,0xE7,0x9C,0x99,0xE7,0x81,0xC3,0xFC,0xC3,0xE7,0x00,0xC3,0xC1,0x83,0xC3,0xC1,0xC3,0xE7,0xF9,0x99,0xC3,0xF9,0x99,0xC3,0x9C,0x99,0xC3,0x9F,0xF9,0x9F,0x83,0xF1,0xC1,0xE7,0xC9,0x99,0xF3,0x81,0xF1,0xE7,0x8F,0xFF,0xEF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x60,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x01,0x80,0xFF,0xFF,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xFF,0xC3,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0xF9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0xFF,0xFF,0xE7,0xFF,0xFF,0xFF,
};




/** @brief DMA2(TCIF) ISR triggered at end of DMA Transfer
 *  
 * No return value or input parameters
*/
void dma2_stream5_isr(void)
{
  // Clear interrupt flag
	dma_clear_interrupt_flags(DMA2, DMA_STREAM5, DMA_TCIF);
  // Wait for SPI to finish, and disable (MOSI idles high == bad)
  while(SPI1_SR & SPI_SR_BSY);
  spi_disable(SPI1);

  // Will video go on this horiz. line?
  // If so prime the DMA with the line start address to avoid jitter
  // when we hit the button in @tim3_isr
  // if it's not going to be visible, set up with a blank line instead.
  if((scan_line >=27) && (scan_line <= 627))
  {
    dma_set_memory_address(DMA2, DMA_STREAM5, (uint32_t) video_buffer[scan_line-27]);
  }
  else 
    dma_set_memory_address(DMA2, DMA_STREAM5, (uint32_t) blank_line);

	// DMA is single transfer mode, so re-enable
	dma_enable_stream(DMA2, DMA_STREAM5); 
  // End of frame? Go back to start
  if(scan_line++ >= 628) scan_line = 0;
}


/** @brief TIM2(UIF) ISR triggered at start of new frame
 * Resets the scan line. That's it 
 * No return value or input parameters
*/
void tim2_isr(void)
{
  // Lazy stewards didn't include a function for this...
  // So clear interrupt bare metal style  
  TIM_SR(TIM2) = ~TIM_SR_UIF;
  // Start of new frame, so just to be sure...  
  scan_line = 0;
}


/** @brief TIM3(CC2IF) ISR triggered at end of  horiz. back porch
 * Starts video output 
 * No return value or input parameters
*/
void tim3_isr(void)
{
  // Did I already call them lazy???
  // But this is the end of the back porch, so re-enable SPI to start the video  
  // and then clear the interrupt
  spi_enable(SPI1);   
  TIM_SR(TIM3) = ~TIM_SR_CC2IF; 
}




/** @brief Configures SPI module 1 complete with associated GPIO Pins
 * Peripheral clock /2 for 40MHz pixel clock (800x600)
 * DMA transfers enabled  
 * No return value or input parameters
*/
static void spi_setup(void)
{
	uint32_t cr_tmp = SPI_CR1_BAUDRATE_FPCLK_DIV_2 |
		 								SPI_CR1_MSTR |
		 								SPI_CR1_SPE |
		 								SPI_CR1_CPHA;
	SPI_CR2(SPI1) |= SPI_CR2_SSOE | SPI_CR2_TXDMAEN;
	SPI_CR1(SPI1) = 0x0000 | cr_tmp;
}


/** @brief Configures DMA module 2 for SPI (module 1) Transfers
 * Stream 5 Channel 3
 * Memory to peripheral, circular mode disabled
 * Interrupt on transfer complete
 * No return value or input parameters
*/
static void dma_setup(void)
{
	// SPI Module 1 uses DMA controller 2 Stream 5 Channel 3
	// Most should be obvious, if not, read the reference manual lol
	nvic_enable_irq(NVIC_DMA2_STREAM5_IRQ);
	dma_stream_reset(DMA2, DMA_STREAM5);
	dma_set_priority(DMA2, DMA_STREAM5, DMA_SxCR_PL_LOW);
	dma_set_memory_size(DMA2, DMA_STREAM5, DMA_SxCR_MSIZE_8BIT);
	dma_set_peripheral_size(DMA2, DMA_STREAM5, DMA_SxCR_PSIZE_8BIT);
	dma_enable_memory_increment_mode(DMA2, DMA_STREAM5);
	dma_set_transfer_mode(DMA2, DMA_STREAM5, DMA_SxCR_DIR_MEM_TO_PERIPHERAL);
	dma_set_peripheral_address(DMA2, DMA_STREAM5, (uint32_t) &SPI1_DR);
	dma_set_memory_address(DMA2, DMA_STREAM5, (uint32_t) video_buffer);
	dma_set_number_of_data(DMA2, DMA_STREAM5, LINE_SIZE);
	dma_enable_transfer_complete_interrupt(DMA2, DMA_STREAM5);
	dma_channel_select(DMA2, DMA_STREAM5, DMA_SxCR_CHSEL_3);
	dma_enable_stream(DMA2, DMA_STREAM5);
}


/** @brief Configures Timers 2 & 3
 * Both timers have Channel 1 for PWM (polarity dependant on video mode)
 * Tim2 = VSync, Tim3 = HSync
 * Tim2 Interrupt on Update
 * Tim3 Interrupt on OC2 - Horiz. Back Porch timing
 * No return value or input parameters
*/
static void timer_setup(void)
{
// Timer global mode: - No divider, Alignment edge, Direction up 
// 	Enable Interrupts for Timers 2 & 3
	nvic_enable_irq(NVIC_TIM2_IRQ);
	nvic_enable_irq(NVIC_TIM3_IRQ);

// Configure Timer 2 to produce VSYNC pulses. Only need OC Output 1 on PA0
// Don't enable until the end, after Timer 3 is configured
// It uses an inverted PWM with the duty equal to the pulse width
// Timer 3 is pre-scaler for Timer 2
	rcc_periph_reset_pulse(RST_TIM2);
	timer_set_mode(TIM2, TIM_CR1_CKD_CK_INT, TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP);
	timer_continuous_mode(TIM2);
	timer_set_period(TIM2, VSYNC_PERIOD);
	timer_disable_oc_output(TIM2, TIM_OC2);
	timer_disable_oc_output(TIM2, TIM_OC3);
	timer_disable_oc_output(TIM2, TIM_OC4);

  // PWM output on Channel 1 - It will be active during the VSync pulse
	timer_enable_oc_output(TIM2, TIM_OC1);
	timer_set_oc_polarity_high(TIM2, TIM_OC1);
	timer_disable_oc_clear(TIM2, TIM_OC1);
	timer_disable_oc_preload(TIM2, TIM_OC1);
	timer_set_oc_slow_mode(TIM2, TIM_OC1);
	timer_set_oc_mode(TIM2, TIM_OC1, TIM_OCM_PWM1);
	timer_set_oc_value(TIM2, TIM_OC1, VSYNC_PULSE);
	timer_disable_preload(TIM2);

  // Not obvious this one... Took it from the Ref Manual
  // and matched up the bit pattern with the library.
	timer_slave_set_mode(TIM2, TIM_SMCR_SMS_ECM1);
  // Configure to receive trigger from Timer 3. Not obvious either :-(
	timer_slave_set_trigger(TIM2, TIM_SMCR_TS_ITR2);
	timer_enable_irq(TIM2,TIM_DIER_UIE);


// Configure Timer 3 to produce HSYNC pulses from Channel 1 OC on PB4,
// and interrupt to pre-configure the DMA (SPI) with the buffer address
// Channel 2 OC used to generate an interrupt which will commence
// the SPI video transfer. No external output needed for this
// It uses an inverted PWM with the duty equal to the pulse width

	rcc_periph_reset_pulse(RST_TIM3);
	timer_set_mode(TIM3, TIM_CR1_CKD_CK_INT, TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP);
	timer_continuous_mode(TIM3);
	timer_set_period(TIM3, HSYNC_PERIOD);
	timer_disable_oc_output(TIM3, TIM_OC3);
	timer_disable_oc_output(TIM3, TIM_OC4);

  // Tim3 OC1 Specific Config, PWM sent to PA6 for HSync Pulse	
	timer_enable_oc_output(TIM3, TIM_OC1);
	timer_set_oc_polarity_high(TIM3, TIM_OC1);
	timer_disable_oc_clear(TIM3, TIM_OC1);
	timer_disable_oc_preload(TIM3, TIM_OC1);
	timer_set_oc_fast_mode(TIM3, TIM_OC1);
	timer_set_oc_mode(TIM3, TIM_OC1, TIM_OCM_PWM1);
	timer_set_oc_value(TIM3, TIM_OC1, HSYNC_PULSE);

  // Tim3 OC2 Specific Config - Used to trigger interrupt at end of back porch
	timer_enable_oc_output(TIM3, TIM_OC2);
	timer_set_oc_polarity_high(TIM3, TIM_OC2);	
	timer_set_oc_fast_mode(TIM3, TIM_OC2);
  // Not really too worried what the output *actually* does... I think...
  // Meh, this works.
	timer_set_oc_mode(TIM3, TIM_OC2, TIM_OCM_TOGGLE);
	timer_set_oc_value(TIM3, TIM_OC2, H_BACKPORCH);

  // Some general config
	timer_disable_preload(TIM3);
	timer_set_master_mode(TIM3, TIM_CR2_MMS_UPDATE);
	timer_enable_irq(TIM3, TIM_DIER_CC2IE);
  // Finally, enable both counters together. Almost.
	timer_enable_counter(TIM2);
	timer_enable_counter(TIM3);
}



/** @brief Configures GPIO Ports A & B for the necessary pins
 * PA5 = VSync
 * PA6 = HSync
 * PB5 = Video Out
 * No return value or input parameters
*/
static void gpio_setup(void)
{
  //	Setup GPIO pins for Tim2 Channels 1 OC with Alt Func AF1.
  // This is VSYNC Output
	gpio_mode_setup(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, V_SYNC_PIN);
	gpio_set_output_options(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, V_SYNC_PIN);	
	gpio_set_af(GPIOA, GPIO_AF1, V_SYNC_PIN);


	//	Setup GPIO pins for Tim3 Channel 1 PWM with Alt Func AF2.
	//  OC1 Will be HSYNC Output
	gpio_mode_setup(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, H_SYNC_PIN);
	gpio_set_output_options(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, H_SYNC_PIN);	
	gpio_set_af(GPIOA, GPIO_AF2, H_SYNC_PIN);


	// PB3 = SPI1 CLK ,PB5 = SPI1 MOSI aka SDO aka COPI aka TRANSMIT.	
	// CLK Isn't actually necessary, so repurposed as interrupt pulse for debugging
	gpio_mode_setup(GPIOB, GPIO_MODE_AF, GPIO_PUPD_PULLDOWN, GPIO5);
	gpio_set_af(GPIOB, GPIO_AF5,  GPIO5);
	gpio_set_output_options(GPIOB, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, GPIO5);
}



/** @brief Configures main system clock
 * Same settings as for 168MHz, except .plln = 320 for 160MHz
 * /2 for APB2 80MHz
 * APB2 /2 for SPI1 = Pixel Clock
 * No return value or input parameters
*/
static void clock_setup(void)
{

const struct rcc_clock_scale rcc_160MHz = 
	{ /* 160MHz */
		.pllm = 8,
		.plln = 320,    // Reduced from 336 to go from 168MHz to 160MHz
		.pllp = 2,
		.pllq = 7,
		.pllr = 0,
		.pll_source = RCC_CFGR_PLLSRC_HSE_CLK,
		.hpre = RCC_CFGR_HPRE_DIV_NONE,
		.ppre1 = RCC_CFGR_PPRE_DIV_4,
		.ppre2 = RCC_CFGR_PPRE_DIV_2,
		.voltage_scale = PWR_SCALE1,
		.flash_config = FLASH_ACR_DCEN | FLASH_ACR_ICEN |
				FLASH_ACR_LATENCY_5WS,
		.ahb_frequency  = 160000000,
		.apb1_frequency = 40000000,  
		.apb2_frequency = 80000000,  // div_by_2 for SPI & Pixel Clock
	};
	rcc_clock_setup_pll(&rcc_160MHz);	

  // And all these peripherals are needed for VGA

	rcc_periph_clock_enable(RCC_GPIOA); // VSync on PA5 (No DAC allowed there, use PA4 instead), Hsync on PA6
	rcc_periph_clock_enable(RCC_GPIOB);	// SPI on PB5 (MOSI) = Mono Video
	rcc_periph_clock_enable(RCC_SPI1);	

	rcc_periph_clock_enable(RCC_DMA2);

	rcc_periph_clock_enable(RCC_TIM2);
	rcc_periph_clock_enable(RCC_TIM3);	
}



/** @brief Externally visible config function
 * Run this to initialise all peripherals needed
 * No return value or input parameters
*/
void vga_setup(void)
{
	clock_setup();
  gpio_setup();
	dma_setup();
	timer_setup();	
	spi_setup();
  // Initialise blank line. Didn't cause any problems in testing without this
  // so probably not needed, but let's do it just in case
  for(uint8_t c = 0 ; c< LINE_SIZE+3 ; c++) blank_line[c] = 0;
}




/*******************************************************************
 *                                                                 *
 *             Now the main user fuctions for the VGA driver       *
 *                                                                 *
 *******************************************************************/



/** @brief Clears the screen and returns cursor to top left x=0, y=0 
 * No return value or input parameters
 * 
 * Pointer stuff contributed by @Xark 
 * Takes 416us at 160MHz
 * 
*/
void vga_clear(void)
{
  uint16_t x;
  uint16_t y;
  uint32_t * dest   = (uint32_t *)&video_buffer[0][0];

  for(y = 0; y< LINES; y++)
  {
    for(x = 0; x< LINE_SIZE/4; x++) //LINE_SIZE is in bytes so /4 for 32 bit chunks
      *dest++ = 0;  
  }
  cursor_x = 0;
  cursor_y = 0;
}


/** @brief Scrolls the screen 1 text line upwards a la command line 
 *
 *  Pointer stuff contributed by @Xark for 32 bit transfers
 *  resulting in 3.15x speed increase over original 8 bit code
 *  Takes 662us at 160 MHz
 *  
 *  No return value or input parameters
 * 
*/
void vga_scroll(void)
{
    uint16_t  x;
    uint16_t  y;
    uint32_t * source = (uint32_t *)&video_buffer[8][0];
    uint32_t * dest   = (uint32_t *)&video_buffer[0][0];

    // Some pointer stuff to do 32 bit copies instead of 8 bit
    // YMMV if Horiz. Resolution is not divisible by 4
    for (y = 0; y < LINES; y++)
    {
        for (x = 0; x < LINE_SIZE/4; x++)
        {
            *dest++ = *source++;
        }
    }
    // Clear the bottom text line for new stuff
    for (y = (LINES - 8); y < LINES; y++)
    {
        for (x = 0; x < LINE_SIZE; x++)
            video_buffer[y][x] = 0;
    }
}


/** @brief Sets TEXT cursor position
@param[in] x uint8_t New Hoziontal Position
@param[in] y uint8_t New Vertical Position
No return value
*/
void vga_set_cursor(uint8_t x, uint8_t y)
{
  cursor_x = x;
  cursor_y = y;
}



/** @brief Writes an individual character to the current cursor position
@param[in] character char. Character to be written
No return value
*/
void write_char(char character)
{
  // Check if printable & copy 8 bytes chargen data to video memory
  if(character >= ' ')
  {
    for(uint8_t c = 0; c < 8; c++)
    {
      video_buffer[((cursor_y*8) +c)][cursor_x] = charset[c][character];
    }
  }

  // Check if we've gone off the end of the screen
  // OR if a \n has been sent
  // if so, scroll up one line
  if((++cursor_x >= LINE_SIZE) || (character == '\n'))
  {
    cursor_x = 0;
    if(++cursor_y >= 75)
    {
      vga_scroll();
      cursor_y = 74;
    }
  }
}


/** @brief Writes a string to the screen at the current cursor position
@param[in] *string char. String to be written
Got this from @tech_paula. She may have borrowed it too :-)
No return value
*/
void vga_puts(char *string)
{
  while(*string)
  {
    write_char(*string);
    string++;
  }
}



/** @brief Writes a long int number to the current cursor position
@param[in] value uint32_t. Number to be displayed
Also Got this from @tech_paula. 
No return value
*/
void vga_putlong(uint32_t value)
{
	char MyString[] = "12345678901234567890";
    itoa(value, MyString, 10);
    vga_puts(MyString);
}


/** @brief Plots an individual pixel to the specified x/y coordinates
@param[in] x uint16_t. X coordinate (0 = left)
@param[in] y uint16_t. Y coordinate (0 = top)
No return value
*/
void vga_plot(uint16_t x, uint16_t y)
{
  uint8_t col, bit;
  col = x/8;
  // need bit position in byte
  bit = x%8;
  // bits are effectively in reverse order, so set MSB and shift left  
  video_buffer[y][col] |= 0x80 >> bit;
}
